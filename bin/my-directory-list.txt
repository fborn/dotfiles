The file cheat contains:
#!/usr/bin/env bash
# A poormans cheatsheet

print_help () {
   printf "  \033[0;33m$1\033[0m: $2\n"
}


printf "VIM\n---\n"
print_help 'ALT + mouse click' 'Put cursor at mouse position'
print_help ':vsp  :sp' 'split vertical and horizontal'
print_help 'CTRL+B' 'page up'
print_help 'CTRL+F' 'page down'
print_help 'CTRL+W |' 'max current split'
print_help 'CTRL+W |' 'max current split'
print_help 'CTRL+W =' 'normalize all split sizes'
print_help 'CTRL+W R' 'swap top/bottom or left/right split'

The file dot contains:
#!/usr/bin/env bash
# Install homebrew packages

# make sure we get the password early
sudo -v

if [[ -z $DOTFILES ]]  
then
    echo "DOTFILES variable not set, exiting"
    exit 1
fi

# start with brew itself
source $DOTFILES/homebrew/brew_install.sh 2>&1 || exit 1

# now process all topical brew packages
for src in $(find "$DOTFILES" -maxdepth 2 -name 'brew_packages')
do
    echo "  Processing installer: $src"
    source "${src}" 2>&1 || exit 1
done

The file githelp contains:
#!/usr/bin/env bash
# a poormans git cheat sheet

print_help () {
   printf "  \033[0;33m$1\033[0m: $2\n"
}


printf "git commands\n------------\n"
print_help 'git reset --hard' 'rollback and discard all uncommitted changes'
print_help 'git reset --soft HEAD~1' 'undo last commit and leave changes staged'
print_help 'git rebase HEAD~[X] -i' 'prepare to squash [X] commits - interactive'
print_help 'git branch -D [branch_name]' 'locally delete branch [branch_name]'

printf "\naliases\n-------\n"
cat $DOTFILES/git/bash_aliases | grep --color=auto git

The file store2evernote contains:
#!/usr/bin/env python 

#This scripts store a textfile straight into evernote
#It used a evernote dev token taken from an env var
#for authentication
#
# Author: 2015-01-02 - Ilja Heitlager

import os
import sys
import argparse
import sys
import logging

from evernote.api.client import EvernoteClient
import evernote.edam.type.ttypes as Types

TOKEN = 'EVERNOTE_DEV_TOKEN'

FORMAT = "%(asctime)-15s %(levelname)s:%(message)s"
logging.basicConfig(format=FORMAT)
LOG=logging.getLogger(__name__)

def process_content(content):
    new_content = '<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE en-note SYSTEM "http://xml.evernote.com/pub/enml2.dtd">'
    new_content += '<en-note>'
    for _line in content:
       new_content += "<div>%s</div>" % _line[:-1]
    new_content += '</en-note>'
    return new_content

def process_note(args, content):
    if args.token:
        LOG.debug("Opening client with explicit token")
    else:
        LOG.debug("Opening client with os env var %s", TOKEN)
    client = EvernoteClient(
        token=args.key,
        sandbox=False,
        )
    userStore = client.get_user_store()
    user = userStore.getUser()
    LOG.debug("Access to evernote account for user %s", user.username)

    LOG.debug('Title: %s', args.title)
    LOG.debug('Note:\n' + content)
    if not args.dryrun:
        note = Types.Note()
        note.title = args.title
        note.content = content
        noteStore = client.get_note_store()
        note = noteStore.createNote(note)
        if not args.quiet:
            LOG.info("Note created with id %s", note.guid)

if __name__ == '__main__':
    parser = argparse.ArgumentParser(description="storing a note into your evernote")
    group = parser.add_mutually_exclusive_group()
    group.add_argument("-d", "--debug", action="store_true", help="explicit debugging mode")
    group.add_argument("-r", "--dryrun", action="store_true", help="dry run only do no store")
    group.add_argument("-v", "--verbose", action="store_true", help="increase verbosity")
    group.add_argument("-q", "--quiet", action="store_true", help="be silent")
    parser.add_argument("--token", type=str, help="explicit token, not using env var %s" % TOKEN)
    parser.add_argument("-t", "--title", type=str, default="uploaded note", help="title for the note to upload")
    parser.add_argument("note", nargs='?', type=argparse.FileType('r'), default=sys.stdin, help="the note to process")
    args = parser.parse_args()
    if args.quiet:
        LOG.setLevel(logging.ERROR)
    elif args.verbose:
        LOG.setLevel(logging.INFO)
    elif args.debug or args.dryrun:
        LOG.setLevel(logging.DEBUG)
    else:
        LOG.setLevel(logging.WARNING)
    if args.token:
        args.key = args.token
    else:
        try:
            args.key = os.environ[TOKEN]
        except KeyError:
            LOG.debug('Get token here: https://www.evernote.com/api/DeveloperToken.action')
            parser.error('Token %s is not set' % TOKEN)
    if args.note == sys.stdin:
        LOG.debug('reading from stdin')
    try:
        LOG.warning("Storing note into evernote")
        process_note(args, process_content(args.note.readlines()))
    except IOError, e:
        LOG.debug(e)
        parser.error('Could not connect to evernote service')

The file tmx contains:
#!/usr/bin/env bash 
#
# Tmux launcher
#
# See:
#     http://github.com/brandur/tmux-extra
#     http://mutelight.org/practical-tmux
#
# Modified version of a script orginally found at:
#     http://forums.gentoo.org/viewtopic-t-836006-start-0.html
# IH: adjusted to make unique based on tty

# Works because bash automatically trims by assigning to variables and by 
# passing arguments
trim() { echo $1; }

if [[ -z "$1" ]]; then
    echo "Specify session name as the first argument"
    exit
fi

# Only because I often issue `ls` to this script by accident
if [[ "$1" == "ls" ]]; then
    tmux ls
    exit
fi

base_session="$1"
# This actually works without the trim() on all systems except OSX
tmux_nb=$(trim `tmux ls | grep "^$base_session" | wc -l`)
if [[ "$tmux_nb" == "0" ]]; then
    echo "Launching tmux base session $base_session ..."
    tmux new-session -s $base_session
else
    # Make sure we are not already in a tmux session
    if [[ -z "$TMUX" ]]; then
        # Kill defunct sessions first (those not attached in a group)
        old_sessions=$(tmux ls 2>/dev/null | egrep "^ttys[0-9]+.*[0-9]+)$" | cut -f 1 -d:)
        for old_session_id in $old_sessions; do
            tmux kill-session -t $old_session_id
        done

        echo "Launching copy of base session $base_session ..."
        # Session is is date and time to prevent conflict
        session_id=$(basename $(tty))
        # Create a new session (without attaching it) and link to base session 
        # to share windows
        tmux new-session -d -t $base_session -s $session_id
        # Attach to the new session
        tmux select-window -t $session_id:1
        tmux attach-session -t $session_id
        # When we detach from it, kill the session
        tmux kill-session -t $session_id
    fi
fi 

